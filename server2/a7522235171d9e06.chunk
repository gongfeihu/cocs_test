  break;
        
        default:
            fprintf(stderr, "No implement other chunking method");
    }
         
    // fastcdc分块
    for (;;) {
        weakhash = 0;  // 重置 weakhash 为当前块的 FastFp
        chunkLength = chunking(fileCache + offset, end - offset, &feature, &weakhash);
        boundary[chunk_num] = chunkLength;
        fastfps[chunk_num] = weakhash;  // 保存当前块的 FastFp
        offset += chunkLength;
        chunk_num += 1;
        if (offset >= end) 
            break;
    }

    // 创建目录并清理之前的 .chunk 文件
    create_directory_if_not_exists("./server1");
    create_directory_if_not_exists("./server2");
    
    printf("Cleaning old chunk files...\n");
    delete_chunk_files_in_directory("./server1");
    delete_chunk_files_in_directory("./server2");
    
    // 删除旧的元数据文件
    delete_metadata_file(input_filename);
    
    // 创建元数据文件，记录块的顺序和位置信息
    char metadata_filename[256];
    snprintf(metadata_filename, sizeof(metadata_filename), "./%s.metadata", input_filename);
    FILE *metadata_file = fopen(metadata_filename, "w");
    if (metadata_file) {
        fprintf(metadata_file, "filename=%s\n", input_filename);
        fprintf(metadata_file, "chunk_count=%d\n", chunk_num);
        fprintf(metadata_file, "chunk_server=server1,server2\n"); // 记录块分布策略
        fclose(metadata_file);
    }
    
    // 输出分块信息（包含 FastFp）并写入块文件到不同目录
    offset = 0;
    for(int i = 0; i < chunk_num; i++){
        printf("Chunk %d: offset=%d, length=%d, fastfp=0x%016lx\n", 
               i, offset, boundary[i], fastfps[i]);
        
        // 生成文件名
        char filename[64];
        sprintf(filename, "%016lx.chunk", fastfps[i]);
        
        // 检查文件是否已存在
        int exists = file_exists_in_server(filename);
        if (exists) {
            printf("  -> File %s already exists in server%d, skipping upload\n", filename, exists);
        } else {
            // 决定保存到哪个目录：偶数块到server1，奇数块到server2
            char filepath[64];
            if (i % 2 == 0) {
                sprintf(filepath, "./server1/%s", filename);
            } else {
                sprintf(filepath, "./server2/%s", filename);
            }
            
            // 写入块文件
            FILE *chunk_file = fopen(filepath, "wb");
            if (chunk_file != NULL) {
                fwrite(fileCache + offset, 1, boundary[i], chunk_file);
                fclose(chunk_file);
                printf("  -> Saved to %s\n", filepath);
            } else {
                printf("  -> Failed to save to %s\n", filepath);
            }
        }
        
        offset += boundary[i];
    }
    
    // 更新元数据文件，添加每个块的详细信息
    metadata_file = fopen(metadata_filename, "a");
    if (metadata_file) {
        for(int i = 0; i < chunk_num; i++) {
            fprintf(metadata_file, "chunk_%d=0x%016lx,%s,%s\n", 
                   i, fastfps[i], 
                   (i % 2 == 0) ? "server1" : "server2",
                   (i % 2 == 0) ? "./server1" : "./server2");
        }
        fclose(metadata_file);
    }
    
    printf("Total chunk number is %d\n", chunk_num);

    free(boundary);  // 释放边界数组内存
    free(fastfps);   // 释放 FastFp 数组内存
    return offset;
}

// 恢复文件函数
int restore_file(const char* input_metadata_filename, const char* output_filename) {
    FILE *output_file = fopen(output_filename, "wb");
    if (!output_file) {
        perror("Failed to open output file for restoration");
        return -1;
    }
    
    printf("Restoring file from chunks using metadata: %s\n", input_metadata_filename);
    
    // 读取元数据文件
    FILE *metadata_file = fopen(input_metadata_filename, "r");
    if (!metadata_file) {
        perror("Failed to open metadata file");
        fclose(output_file);
        return -1;
    }
    
    char line[512];
    int chunk_count = 0;
    char filename[256];
    
    // 读取基本元数据
    while (fgets(line, sizeof(line), metadata_file)) {
        if (strncmp(line, "chunk_count=", 12) == 0) {
            sscanf(line, "chunk_count=%d", &chunk_count);
        } else if (strncmp(line, "filename=", 9) == 0) {
            sscanf(line, "filename=%s", filename);
        }
    }
    
    // 重置文件指针以读取块信息
    rewind(metadata_file);
    
    // 创建一个临时数组来存储块信息
    char **chunk_fps = malloc(chunk_count * sizeof(char*));
    char **chunk_servers = malloc(chunk_count * sizeof(char*));
    for(int i = 0; i < chunk_count; i++) {
        chunk_fps[i] = malloc(17); // 16 hex chars + null terminator
        chunk_servers[i] = malloc(8); // "server1" or "server2" + null terminator
    }
    
    // 读取块信息
    while (fgets(line, sizeof(line), metadata_file)) {
        int chunk_idx;
        char chunk_fp[17], server[8];
        if (sscanf(line, "chunk_%d=0x%16s,%7s,", &chunk_idx, chunk_fp, server) == 3) {
            if (chunk_idx >= 0 && chunk_idx < chunk_count) {
                strcpy(chunk_fps[chunk_idx], chunk_fp);
                strcpy(chunk_servers[chunk_idx], server);
            }
        }
    }
    
    fclose(metadata_file);
    
    // 按顺序恢复文件
    for (int i = 0; i < chunk_count; i++) {
        char chunk_filename[64];
        snprintf(chunk_filename, sizeof(chunk_filename), "%s.chunk", chunk_fps[i]);
        
        char filepath[512];
        snprintf(filepath, sizeof(filepath), "./%s/%s", chunk_servers[i], chunk_filename);
        
        FILE *chunk_file = fopen(filepath, "rb");
        if (chunk_file) {
            // 获取文件大小
            fseek(chunk_file, 0, SEEK_END);
            long chunk_size = ftell(chunk_file);
            fseek(chunk_file, 0, SEEK_SET);
            
            // 读取并写入块数据
            unsigned char *chunk_data = malloc(chunk_size);
            if (chunk_data) {
                fread(chunk_data, 1, chunk_size, chunk_file);
                fwrite(chunk_data, 1, chunk_size, output_file);
                free(chunk_data);
            }
            fclose(chunk_file);
            printf("  -> Restored chunk %d from %s\n", i, filepath);
        } else {
            printf("  -> Chunk %d not found at %s\n", i, filepath);
        }
    }
    
    // 释放内存
    for(int i = 0; i < chunk_count; i++) {
        free(chunk_fps[i]);
        free(chunk_servers[i]);
    }
    free(chunk_fps);
    free(chunk_servers);
    
    fclose(output_file);
    printf("File restoration completed: %s\n", output_filename);
    return 0;
}

// functions
void fastCDC_init(void) {
    unsigned char md5_digest[16];
    uint8_t seed[SeedLength];
    for (int i = 0; i < SymbolCount; i++) {

        for (int j = 0; j < SeedLength; j++) {
            seed[j] = i;
        }

        g_global_matrix[i] = 0;
        MD5(seed, SeedLength, md5_digest);
        memcpy(&(g_global_matrix[i]), md5_digest, 4);
        g_global_matrix_left[i] = g_global_matrix[i] << 1;
    }

    // 64 bit init
    for (int i = 0; i < SymbolCount; i++) {
        LEARv2[i] = GEARv2[i] << 1;
    }

    MinSize = 8192 / 4;
    MaxSize = 8192 * 4;    // 32768;
    Mask_15 = 0xf9070353;  //  15个1
    Mask_11 = 0xd9000353;  //  11个1
    Mask_11_64 = 0x0000d90003530000;
    Mask_15_64 = 0x0000f90703530000;
    MinSize_divide_by_2 = MinSize / 2;
}

int normalized_chunking_64(unsigned char *p, int n,uint64_t *feature,uint64_t *weakhash) {
    uint64_t fingerprint = 0, digest;
    int originalMinSize = MinSize;
    MinSize = 6 * 1024;
    int i = MinSize, Mid = 8 * 1024;

    // the minimal subChunk Size.
    if (n <= MinSize)  
        return n;

    if (n > MaxSize)
        n = MaxSize;
    else if (n < Mid)
        Mid = n;

    while (i < Mid) {
        fingerprint = (fingerprint << 1) + (GEARv2[p[i]]);

        if ((!(
fingerprint & FING_GEAR_32KB_64))) {
            MinSize = originalMinSize;  // 恢复原始MinSize
            return i;
        }

        i++;
    }

    while (i < n) {
        fingerprint = (fingerprint << 1) + (GEARv2[p[i]]);

        if ((!(fingerprint & FING_GEAR_02KB_64))) {
            MinSize = originalMinSize;  // 恢复原始MinSize
            return i;
        }

        i++;
    }

    MinSize = originalMinSize;  // 恢复原始MinSize
    return n;
}

int normalized_chunking_2byes_64(unsigned char *p, int n,uint64_t *feature,uint64_t *weakhash) {
    uint64_t fingerprint = 0, digest;
    int originalMinSize = MinSize;
    MinSize = 6 * 1024;
    int i = MinSize / 2, Mid = 8 * 1024;

    // the minimal subChunk Size.
    if (n <= MinSize) 
        return n;

    if (n > MaxSize)
        n = MaxSize;
    else if (n < Mid)
        Mid = n;

    while (i < Mid / 2) {
        int a = i * 2;
        fingerprint = (fingerprint << 2) + (LEARv2[p[a]]);

        if ((!(fingerprint & FING_GEAR_32KB_ls_64))) {
            MinSize = originalMinSize;  // 恢复原始MinSize
            return a;
        }

        fingerprint += GEARv2 [p[a + 1]];  

        if ((!(fingerprint & FING_GEAR_32KB_64))) {
            MinSize = originalMinSize;  // 恢复原始MinSize
            return a + 1;
        }

        i++;
    }

    while (i < n / 2) {
        int a = i * 2;
        fingerprint = (fingerprint << 2) + (LEARv2[p[a]]);

        if ((!(fingerprint & FING_GEAR_02KB_ls_64))) {
            MinSize = originalMinSize;  // 恢复原始MinSize
            return a;
        }

        fingerprint += GEARv2[p[a + 1]];

        if ((!(fingerprint & FING_GEAR_02KB_64))) {
            MinSize = originalMinSize;  // 恢复原始MinSize
            return a + 1;
        }

        i++;
    }

    MinSize = originalMinSize;  // 恢复原始MinSize
    return n;
}

int rolling_data_2byes_64(unsigned char *p, int n,uint64_t *feature,uint64_t *weakhash) {
    uint64_t fingerprint = 0, digest;
    int i = MinSize_divide_by_2;

    // the minimal subChunk Size.
    if (n <= MinSize) 
        return n;

    if (n > MaxSize) n = MaxSize;

    while (i < n / 2) {
        int a = i * 2;
        fingerprint = (fingerprint << 2) + (LEARv2[p[a]]);

        if ((!(fingerprint & FING_GEAR_08KB_ls_64))) {
            return a;
        }

        fingerprint += GEARv2[p[a + 1]];

        if ((!(fingerprint & FING_GEAR_08KB_64))) {
            return a + 1;
        }

        i++;
    }

    return n;
}

int cdc_origin_64(unsigned char *p, int n,uint64_t *feature,uint64_t *weakhash){
    uint64_t fingerprint = 0, digest;
    *weakhash = 0;
    int i = 0, ptr = 0;

    // The chunk size cannot exceed remaining length of file and MaxSize.
    n = n < MaxSize ? n : MaxSize;

    while (i < n) {
        fingerprint = (fingerprint << 1) + (GEARv2[p[i]]);
        *feature = *feature > fingerprint ? *feature : fingerprint;
        if (i > MinSize && (!(fingerprint & FING_GEAR_08KB_64))) {
            return i + 1;
        }
        i++;
        ptr++;
        if(ptr % STEP == 0){
            *weakhash += fingerprint;
        }
    }

    return n;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <input_file> [restore_output_file]\n", argv[0]);
        fprintf(stderr, "  Example: %s myfile.bin                    # 分块处理\n", argv[0]);
        fprintf(stderr, "  Example: %s myfile.bin restored.bin      # 恢复文件\n", argv[0]);
        exit(1);
    }
    
    gettimeofday(&tmStart, NULL);
    
    if (argc == 2) {
        // 分块处理模式
        FILE* read = fopen(argv[1], "rb");  // 从命令行参数获取输入文件
        if (read == NULL) {
            perror("Fail to open file");
            exit(-1);
        }
        
        // 使用较小的缓存大小以避免内存问题
        unsigned char *fileCache = (unsigned char *)malloc(MAX_CACHE_SIZE);
        if (fileCache == NULL) {
            perror("Memory allocation failed for file cache");
            fclose(read);
            exit(-1);
        }
        
        int n = fastcdc_chunking(read, fileCache, argv[1]);
        
        printf("Processed %d bytes from %s\n", n, argv[1]);
        
        gettimeofday(&tmEnd, NULL);
        totalTm = (tmEnd.tv_sec - tmStart.tv_sec) * 1000000 + tmEnd.tv_usec - tmStart.tv_usec;
        printf("Total time is %f s\n", totalTm / 1000000);
        
        free(fileCache);
        fclose(read);
    } else if (argc == 3) {
        // 恢复模式
        char metadata_filename[256];
        snprintf(metadata_filename, sizeof(metadata_filename), "./%s.metadata", argv[1]);
        printf("Restoring file to: %s using metadata: %s\n", argv[2], metadata_filename);
        restore_file(metadata_filename, argv[2]);
    }
    
    return 0;
}